package org.octavius.database.transaction

import io.github.oshai.kotlinlogging.KotlinLogging
import org.octavius.data.DataResult
import org.octavius.data.exception.*
import org.octavius.data.transaction.*
import org.springframework.jdbc.datasource.DataSourceTransactionManager
import org.springframework.transaction.TransactionDefinition
import org.springframework.transaction.support.TransactionTemplate

/**
 * Executes a series of database operations in a single, atomic transaction.
 *
 * Key features:
 * - **Atomicity**: All operations succeed or none (rollback).
 * - **Dependencies**: Results from one step can be used as parameters in subsequent steps.
 * - **Parameter Expansion**: Automatic conversion of complex Kotlin types
 *   (lists, data classes, enums) to native PostgreSQL constructs.
 * - **RETURNING Support**: Retrieves values generated by the database.
 *
 * @param transactionManager Spring transaction manager.
 *
 * @see TransactionStep
 * @see TransactionValue
 * @see org.octavius.database.type.KotlinToPostgresConverter
 */
internal class TransactionPlanExecutor(
    private val transactionManager: DataSourceTransactionManager,
) {
    companion object {
        private const val SCALAR_RESULT_KEY = "result"
        private val logger = KotlinLogging.logger {}
    }

    fun execute(plan: TransactionPlan, propagation: TransactionPropagation): DataResult<TransactionPlanResult> {
        val stepsWithHandles = plan.steps // Retrieve list of (Handle, Step) pairs
        if (stepsWithHandles.isEmpty()) {
            logger.debug { "Executing an empty transaction plan." }
            return DataResult.Success(TransactionPlanResult(emptyMap()))
        }
        return runCatching {
            // Step 1: Create a map for quick translation of handles to indices
            val handleToIndexMap = validatePlan(stepsWithHandles)

            // Step 2: Prepare transaction template
            val transactionTemplate = createTransactionTemplate(propagation)

            val finalResultsMap = transactionTemplate.execute {
                executeStepsInTransaction(stepsWithHandles, handleToIndexMap)
            }

            // If transaction succeeded, wrap result in Success
            DataResult.Success(TransactionPlanResult(finalResultsMap))

        }.getOrElse { error ->
            // Step 4: Error handling at the highest level
            handleTransactionError(error)
        }
    }

    private fun validateTransactionValue(
        value: Any?,
        currentIndex: Int,
        handleToIndexMap: Map<StepHandle<*>, Int>
    ) {
        when (value) {
            is TransactionValue.FromStep -> {
                val sourceIndex = handleToIndexMap[value.handle]
                    ?: throw StepDependencyException(StepDependencyExceptionMessage.UNKNOWN_STEP_HANDLE, currentIndex)

                if (sourceIndex >= currentIndex) {
                    throw StepDependencyException(
                        StepDependencyExceptionMessage.DEPENDENCY_ON_FUTURE_STEP,
                        currentIndex,
                        sourceIndex
                    )
                }
            }
            is TransactionValue.Transformed -> {
                // Validate what's inside.
                validateTransactionValue(value.source, currentIndex, handleToIndexMap)
            }
            // Other types (Value, regular values) don't require validation, so we do nothing.
        }
    }

    private fun validatePlan(stepsWithHandles: List<Pair<StepHandle<*>, TransactionStep<*>>>): Map<StepHandle<*>, Int> {
        val handleToIndexMap = stepsWithHandles.withIndex().associate { (index, pair) -> pair.first to index }

        for ((currentIndex, pair) in stepsWithHandles.withIndex()) {
            val step = pair.second
            for (paramValue in step.params.values) {
                validateTransactionValue(paramValue, currentIndex, handleToIndexMap)
            }
        }

        logger.info { "Transaction plan validated successfully. Executing ${stepsWithHandles.size} steps." }
        return handleToIndexMap
    }

    private fun createTransactionTemplate(propagation: TransactionPropagation): TransactionTemplate {
        return TransactionTemplate(transactionManager).apply {
            propagationBehavior = when (propagation) {
                TransactionPropagation.REQUIRED -> TransactionDefinition.PROPAGATION_REQUIRED
                TransactionPropagation.REQUIRES_NEW -> TransactionDefinition.PROPAGATION_REQUIRES_NEW
                TransactionPropagation.NESTED -> TransactionDefinition.PROPAGATION_NESTED
            }
        }
    }

    private fun executeStepsInTransaction(
        stepsWithHandles: List<Pair<StepHandle<*>, TransactionStep<*>>>,
        handleToIndexMap: Map<StepHandle<*>, Int>
    ): Map<StepHandle<*>, Any?> {
        val indexedResults = mutableMapOf<Int, Any?>()

        for ((index, pair) in stepsWithHandles.withIndex()) {
            val step = pair.second
            try {
                executeSingleStep(index, step, indexedResults, handleToIndexMap)
            } catch (e: Exception) {
                // Wrap EVERY error in step context and throw it to rollback the transaction
                throw TransactionStepExecutionException(stepIndex = index, cause = e)
            }
        }

        // After successfully executing all steps, create the final results map
        return stepsWithHandles.associate { (handle, _) ->
            handle to indexedResults.getValue(handleToIndexMap.getValue(handle))
        }
    }

    private fun executeSingleStep(
        index: Int,
        step: TransactionStep<*>,
        indexedResults: MutableMap<Int, Any?>, // We modify this map
        handleToIndexMap: Map<StepHandle<*>, Int>
    ) {
        logger.debug { "Executing step $index..." }

        // Resolve references and build final parameters
        val finalParams = buildFinalParameters(step, indexedResults, handleToIndexMap)
        logger.trace { "--> Final params for step $index: $finalParams" }

        // Execute step logic
        // Handle step result
        when (val stepResult = step.executionLogic(step.builder, finalParams)) {
            is DataResult.Success -> {
                indexedResults[index] = stepResult.value
            }
            is DataResult.Failure -> {
                // Throw error, it will be caught one level up and wrapped
                throw stepResult.error
            }
        }
    }

    private fun buildFinalParameters(
        step: TransactionStep<*>,
        indexedResults: Map<Int, Any?>,
        handleToIndexMap: Map<StepHandle<*>, Int>
    ): Map<String, Any?> {
        val resolvedParams = step.params.mapValues { (_, value) ->
            resolveReference(value, indexedResults, handleToIndexMap)
        }

        val finalParams = mutableMapOf<String, Any?>()
        resolvedParams.forEach { (key, resolvedValue) ->
            val originalParam = step.params[key]
            if (originalParam is TransactionValue.FromStep.Row && resolvedValue is Map<*, *>) {
                @Suppress("UNCHECKED_CAST")
                finalParams.putAll(resolvedValue as Map<String, Any?>)
            } else {
                finalParams[key] = resolvedValue
            }
        }
        return finalParams
    }

    private fun handleTransactionError(error: Throwable): DataResult.Failure {
        val dbException = when (error) {
            is DatabaseException -> error
            else -> TransactionException(error)
        }
        logger.error(dbException) { "Transaction failed and was rolled back." }
        return DataResult.Failure(dbException)
    }


    private fun resolveReference(
        value: Any?,
        indexedResults: Map<Int, Any?>,
        handleToIndexMap: Map<StepHandle<*>, Int>
    ): Any? {
        if (value !is TransactionValue) {
            return value // Regular value
        }

        return when (value) {
            is TransactionValue.Value -> value.value // Unwrap
            is TransactionValue.Transformed -> resolveTransformed(value, indexedResults, handleToIndexMap)
            is TransactionValue.FromStep -> resolveFromStep(value, indexedResults, handleToIndexMap)
        }
    }

    // Helper function to find the "culprit" (handle) deep in nested structures
    private fun extractRootHandle(value: TransactionValue): StepHandle<*>? {
        return when (value) {
            is TransactionValue.FromStep -> value.handle
            is TransactionValue.Transformed -> extractRootHandle(value.source)
            else -> null
        }
    }
    private fun resolveTransformed(
        value: TransactionValue.Transformed,
        indexedResults: Map<Int, Any?>,
        handleToIndexMap: Map<StepHandle<*>, Int>
    ): Any? {
        // First retrieve the "raw" value from inside (recursion!)
        val rawValue = resolveReference(value.source, indexedResults, handleToIndexMap)

        // Apply user-provided function
        return try {
            value.transform(rawValue)
        } catch (e: Exception) {
            // We need to determine which step this transformation was related to.
            // Since Transformed wraps another value (e.g., FromStep),
            // we need to "dig down" to the handle to provide the correct stepIndex in the error.
            val rootHandle = extractRootHandle(value.source)
            val stepIndex = rootHandle?.let { handleToIndexMap[it] } ?: -1

            throw StepDependencyException(
                messageEnum = StepDependencyExceptionMessage.TRANSFORMATION_FAILED,
                referencedStepIndex = stepIndex,
                args = arrayOf(e.message ?: e.toString()),
                cause = e
            )
        }
    }

    private fun resolveFromStep(
        value: TransactionValue.FromStep,
        indexedResults: Map<Int, Any?>,
        handleToIndexMap: Map<StepHandle<*>, Int>
    ): Any? {
        val stepIndex = handleToIndexMap[value.handle]!! // Validated earlier
        // The `execute` loop logic guarantees that if we reached this point,
        // step `stepIndex` has been executed and its result is in the map.
        val sourceResult = indexedResults[stepIndex] ?: return null // Step result can be null

        return when (value) {
            is TransactionValue.FromStep.Field -> resolveField(value, sourceResult, stepIndex)
            is TransactionValue.FromStep.Column -> resolveColumn(value, sourceResult, stepIndex)
            is TransactionValue.FromStep.Row -> sourceResult.toRowMap(value.rowIndex, stepIndex)
        }
    }

    private fun resolveField(
        value: TransactionValue.FromStep.Field,
        sourceResult: Any, // We know it's not null from the previous step
        stepIndex: Int
    ): Any? {
        val rowData = sourceResult.toRowMap(value.rowIndex, stepIndex)
        val colName = value.columnName ?: SCALAR_RESULT_KEY

        if (!rowData.containsKey(colName)) {
            val errorMsg = if (value.columnName == null) {
                StepDependencyExceptionMessage.SCALAR_NOT_FOUND
            } else {
                StepDependencyExceptionMessage.COLUMN_NOT_FOUND
            }
            throw StepDependencyException(errorMsg, stepIndex, colName)
        }
        return rowData[colName]
    }

    private fun resolveColumn(
        value: TransactionValue.FromStep.Column,
        sourceResult: Any, // We know it's not null
        stepIndex: Int
    ): List<Any?> {
        // toList, toColumn, toListOf
        val sourceList = sourceResult as? List<*>
            ?: throw StepDependencyException(StepDependencyExceptionMessage.RESULT_NOT_LIST, stepIndex)

        if (value.columnName == null) {
            return sourceList
        }

        val columnName = value.columnName!!

        return sourceList.map { element ->
            val row = element as? Map<*, *>
                ?: throw StepDependencyException(StepDependencyExceptionMessage.RESULT_NOT_MAP_LIST, stepIndex)

            // Check if key exists.
            if (!row.containsKey(columnName)) {
                throw StepDependencyException(StepDependencyExceptionMessage.COLUMN_NOT_FOUND, stepIndex, columnName)
            }

            // Safely retrieve the value.
            row[columnName]
        }
    }

    @Suppress("UNCHECKED_CAST")
    // `toRowMap` signature accepts `Any`, because `null` is handled earlier in `resolveReference`.
    private fun Any.toRowMap(rowIndex: Int, stepIndex: Int): Map<String, Any?> {
        return when (this) {
            // toList, toColumn, toListOf
            is List<*> -> {
                if (rowIndex >= this.size) {
                    throw StepDependencyException(StepDependencyExceptionMessage.ROW_INDEX_OUT_OF_BOUNDS, stepIndex, rowIndex, this.size)
                }
                when (val element = this[rowIndex]) {
                    // toList result - an empty map may be returned - no nulls
                    is Map<*, *> -> element as Map<String, Any?>
                    // toListOf passes - error in converter for non-composites
                    // or toColumn - the element can be null
                    else -> mapOf(SCALAR_RESULT_KEY to element)
                }
            }
            // toSingle
            is Map<*, *> -> {
                if (rowIndex > 0) {
                    throw StepDependencyException(StepDependencyExceptionMessage.INVALID_ROW_ACCESS_ON_NON_LIST, stepIndex, rowIndex)
                }
                this as Map<String, Any?>
            }
            // toSingleOf, toField, execute
            else -> {
                if (rowIndex > 0) {
                    throw StepDependencyException(StepDependencyExceptionMessage.INVALID_ROW_ACCESS_ON_NON_LIST, stepIndex, rowIndex)
                }
                // toSingleOf result (error in converter and type registry when used on non-composite)
                // toField can be null, but execute cannot
                mapOf(SCALAR_RESULT_KEY to this)
            }
        }
    }
}
